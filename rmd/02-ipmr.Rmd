# Chapter 1: ipmr: an R package to flexibly implement Integral Projection Models


## Abstract

1. Integral projection models (IPMs) are an important tool for studying the dynamics of populations structured by one or more continuous traits (_e.g._ size, height, body mass). Researchers use IPMs to investigate questions ranging from linking drivers to population dynamics, planning conservation and management strategies, and quantifying selective pressures in natural populations. The popularity of stage-structured population models has been supported by _R_ scripts and packages (_e.g._ `IPMpack`, `popbio`, `popdemo`, `lefko3`) aimed at ecologists, which have introduced a broad repertoire of functionality and outputs. However, pressing ecological, evolutionary, and conservation biology topics require developing more complex IPMs, and considerably more expertise to implement them. Here, we introduce `ipmr`, a flexible _R_ package for building, analyzing, and interpreting IPMs.

2. The `ipmr` framework relies on the mathematical notation of the models to express them in code format. Additionally, this package  decouples the model parameterization step from the model implementation step. The latter point substantially increases `ipmr`'s flexibility to model complex life cycles and demographic processes. 

3. `ipmr` can handle a wide variety of models, including those that incorporate density dependence, discretely and continuously varying stochastic environments, and multiple continuous and/or discrete traits. `ipmr` can accommodate models with individuals cross-classified by age and size. Furthermore, the package provides methods for demographic analyses (_e.g._ asymptotic and stochastic growth rates) and visualization (_e.g._ kernel plotting).

4. `ipmr` is a flexible _R_ package for integral projection models. The package substantially reduces the amount of time required to implement general IPMs. We also provide extensive documentation with six vignettes and help files, accessible from an R session and online.

Keywords: elasticity, integral projection model, life history, population dynamics, population growth rate, sensitivity, structured populations

## Introduction

Integral projection models (IPMs) are an important and widely used tool for ecologists studying structured population dynamics in discrete time. Since the paper introducing IPMs was published over two decades ago (Easterling et al., 2000), at least 255 peer-reviewed publications on at least 250 plant species and 60 animal species have used IPMs (Figure S1.XXX). These models have addressed questions ranging from invasive species population dynamics (_e.g._ Crandall & Knight, 2017), effect of climate drivers on population persistence (_e.g._ Compagnoni et al., 2021), evolutionary stable strategies (_e.g._ Childs et al., 2004), and rare/endangered species conservation (_e.g._ Ferrer-Cervantes et al., 2012).

The IPM was introduced as alternative to matrix population models, which model populations structured by discrete traits (Caswell, 2001). Some of the advantages of using an IPM include (i) the ability to model populations structured by continuously distributed traits, (ii) the ability to flexibly incorporate discrete and continuous traits in the same model (_e.g._ seeds in a seedbank and a height structured plant population (Crandall & Knight, 2017), or number of females, males, and age-1 recruits for fish species (Erickson et al., 2017)), (iii) efficient parameterization of demographic processes with familiar regression methods (Coulson, 2012), and (iv) the numerical discretization of continuous kernels (see below) means that the tools available for matrix population models are usually also applicable for IPMs. Furthermore, researchers have developed methods to incorporate spatial dynamics (Jongejans et al., 2011), environmental stochasticity (Rees & Ellner, 2009), and density/frequency dependence into IPMs (Adler et al., 2010, Ellner et al., 2016). These developments were accompanied by the creation of software tools and guides to assist with IPM parameterization, implementation, and analysis. These tools range from _R_ scripts with detailed annotations (Coulson, 2012, Merow et al., 2014, Ellner et al., 2016) to _R_ packages (Metcalf et al., 2013, Shefferson et al., 2020).

Despite the array of resources available to researchers, implementing an IPM is still not a straightforward exercise. For example, an IPM that simulates a population for 100 time steps requires the user to either write or adapt from published guides multiple functions (_e.g._ to summarize demographic functions into the proper format), implement the numerical approximations of the model's integrals, ensure that individuals are not accidentally sent beyond the integration bounds ("unintentional eviction", _sensu_ Williams et al., 2012), and track how the population state changes over the course of a simulation. Stochastic IPMs present further implementation challenges. In addition to the aforementioned elements, users must generate the sequence of environments that the population experiences. There are multiple ways of simulating environmental stochasticity, each with their own strengths and weaknesses (Metcalf et al. 2015).

`ipmr` manages these key details while providing the user flexibility in their models. `ipmr` uses the `rlang` package for metaprogramming (Henry & Wickham, 2019), which enables `ipmr` to provide a miniature domain specific language for implementing IPMs. `ipmr` aims to mimic the mathematical syntax that describes IPMs as closely as possible (Fig. 1.1, Box 1.1, Tables 1.1 and 1.2). This _R_ package can handle models with individuals classified by a mixture of any number of continuously and discretely distributed traits. Furthermore, `ipmr` introduces specific classes and methods to deal with both discretely and continuously varying stochastic environments, density-independent and -dependent models, as well as age structured populations (Case Study 2). `ipmr` decouples the parameterization (_i.e._ regression model fitting) and implementation steps (_i.e._ converting the regression parameters into a full IPM), and does not attempt to help users with the parameterization task. This provides greater flexibility in modeling trait-demography relationships, and enables users to specify IPMs of any functional form that they desire.

## Terminology and IPM construction

An IPM describes how the abundance and distribution of trait values (also called _state variables_/*states*, denoted $z$ and $z'$) for a population changes in discrete time. The distribution of trait values in a population at time $t$ is given by the function $n(z,t)$. A simple IPM for the trait distribution $z'$ at time $t+1$ is then   

$$n(z', t+1) = \int_L^UK(z',z)n(z,t)dz. \tag{1.1}$$

$K(z',z)$, known as the _projection kernel_, describes all possible transitions of existing individuals and recruitment of new individuals from $t$ to $t+1$, generating a new trait distribution $n(z',t+1)$. $L,U$ are the lower and upper bounds for values that the trait $z$ can have, which defines the _domain_ over which the integration is performed. The integral $\int_L^Un(z,t)dz$ gives the total population size at time $t$. 

To make the model more biologically interpretable, the projection kernel $K(z',z)$ is usually split into _sub-kernels_ (Eq 1.2). For example, a projection kernel to describe a lifecycle where individuals can survive, transition to different state values, and reproduce via sexual and asexual pathways, can be split as follows

$$K(z',z) = P(z',z) + F(z',z) + C(z',z), \tag{1.2}$$ 

where $P(z',z)$ is a sub-kernel describing transitions due to survival and trait changes of existing individuals, $F(z',z)$ is a sub-kernel describing per-capita sexual contributions of existing individuals to recruitment, and $C(z',z)$ is a sub-kernel describing per-capita asexual contributions of existing individuals to recruitment. The sub-kernels are typically comprised of functions derived from regression models that relate an individual's trait value $z$ at time $t$ to a new trait value $z'$ at $t+1$. For example, the $P$ kernel for Soay sheep (_Ovis aries_) on St. Kilda (Eq 1.3) may contain two regression models: (i) a logistic regression of survival on log body mass (Eq 1.4), and (ii) a linear regression of log body mass at $t+1$ on log body mass at $t$ (Eq 1.5-1.6). In this example, $f_G$ is a normal probability density function with $\mu_G$ given by the linear predictor of the mean, and with $\sigma_G$ computed from the standard deviation of the residuals from the linear regression model.

$$P(z',z) = s(z) * G(z',z), \tag{1.3}$$

$$Logit(s(z)) = \alpha_s + \beta_s * z, \tag{1.4}$$ 

$$G(z',z) = f_G(z', \mu_G, \sigma_G), \tag{1.5}$$  

$$\mu_G = \alpha_G + \beta_G * z. \tag{1.6}$$ 

Analytical solutions to the integral in Eq 1.1 are usually not possible (Ellner & Rees, 2006). However, numerical approximations of these integrals can be constructed using a numerical integration rule. A commonly used rule is the midpoint rule (more complicated and precise methods are possible and will be implemented, though are not yet, see Ellner et al., 2016, Chapter 6). The midpoint rule divides the domain $[L,U]$ into $m$ artifical size bins centered at $z_i$ with width $h = (U-L) / m$. The midpoints $z_i = L + (i - 0.5) * h$ for $i = \textrm{1, 2, ...}, m$. The midpoint rule approximation for Eq 1.1 then becomes:

$$n(z_j, t+1) = h\sum\limits_{i = 1}^mK(z_j, z_i)n(z_i,t) \tag{1.7}$$

In practice, the numerical approximation of the integral converts the continuous projection kernel into a (large) discretized matrix. A matrix multiplication of the discretized projection kernel and the discretized trait distribution then generates a new trait distribution, a process referred to as _model iteration_ (_sensu_ Easterling et al., 2000). 

Equations 1.1 and 1.2 are an example of a _simple IPM_. A critical aspect of `ipmr`'s functionality is the distinction between _simple IPMs_ and _general IPMs_. A simple IPM incorporates a single continuous state variable. Equations 1.1 and 1.2 represent a simple IPM because there is only one continuous state, $z$, and no additional discrete states. A general IPM models one or more continuous state variables, and/or discrete states. General IPMs are useful for modelling species with more complex life cycles. Many species' life cycles contain multiple life stages that are not readily described by a single state variable. Similarly, individuals with similar trait values may behave differently depending on environmental context. For example, Bruno et al. (2011) modeled aspergillosis impacts on sea fan coral (_Gorgonia ventalina_) population dynamics by creating a model where colonies were cross classified by tissue area (continuously distributed) and infection status (a discrete state with two levels - infected and uninfected). Coulson, Tuljapurkar & Childs (2010) constructed a model for Soay sheep where the population was structured by body weight (continuously distributed) and age (discrete state). Mixtures of multiple continuous and discrete states are also possible. Indeed, the vital rates of many species with complex life cycles are often best described with multivariate state distributions (Caswell & Salguero-Gómez, 2013). A complete definition of the simple/general distinction is given in Ellner et al. (2016, Chapter 6). 

\newpage

```{r warning = FALSE, fig.cap = "Figure 1.1: There are generally 6 steps in defining an IPM with `ipmr`. (1) Vital rate models are fit to demographic data collected from field sites. This step requires the use of other packages, as `ipmr` does not contain facilities for regression modeling. The figure on the left shows the fitted relationship between size at $t$ and $t+1$ for _Carpobrotus spp._ in Case Study 1. (2) The next step is deciding what type of IPM is needed. This is determined by both the research question and the data used to parameterize the regression models. This process is initiated with `init_ipm()`. In step (3), kernels are defined using `ipmr`'s syntax to represent kernels and vital rate functions. (4) Having defined symbolic representations of the model, the numerical definition is given. Here, the integration rule, domain bounds, and initial population conditions are defined. For some models, initial environmental conditions can also be defined. (5) `make_ipm()` numerically implements the `proto_ipm` object, (6) which can then be analyzed further. The figure at the bottom left shows a $K(z',z)$ kernel created by `make_ipm()` and `make_iter_kernel()`. The line plots above and to the right display the left and right eigenvectors, extracted with `left_ev()` and `right_ev()`, respectively.", echo = FALSE, dpi = 450, fig.height = 14, fig.width = 14}

library(png) 
library(ggplot2)
library(grid)
library(gridExtra)
library(knitr)
library(kableExtra)

fig <- readPNG("Figures/ex_workflow.png")

fig_grob <- rasterGrob(fig, interpolate = TRUE)

plt <- qplot(1:14, 1:14, geom = "blank") +
  annotation_custom(fig_grob,
                    xmin = -Inf,
                    xmax = Inf,
                    ymin = -Inf,
                    ymax = Inf) +
  theme_void()

print(plt)


```

\newpage

## A brief worked example of a simple IPM with `ipmr`

Box 1.1 shows a brief example of how `ipmr` converts parameter estimates into an IPM. Perhaps the most frequently used metric derived from IPMs is the asymptotic per-capita population growth rate ($\lambda$, Caswell 2001). When $\lambda > 1$, the population is growing, while $\lambda < 1$ indicates population decline. `ipmr` makes deriving estimates of $\lambda$ straightforward. Box 1.1 demonstrates how to parameterize a simple, deterministic IPM and estimate $\lambda$. The example uses a hypothetical species that can survive and grow, and reproduce sexually (but not asexually, so $C(z',z) = 0$ in Equation 2). The population is structured by size, denoted $z$ and $z’$, and there is no seedbank.

The $P(z',z)$ kernel is given by Eq 1.3, and the vital rates therein by Eq 1.4-1.6. The $F(z',z)$ kernel is given Eq 1.8:

$$F(z',z) = r_d(z') * r_n(z), \tag{1.8}$$ 

$$r_d(z') = f_{r_d}(z', \mu_{r_d}, \sigma_{r_d}), \tag{1.9}$$ 

$$Log(r_n(z))  = \alpha_{r_n} + \beta_{r_n} * z. \tag{1.10}$$ 

Eq 1.9 is a recruit size distribution (where $f_{r_d}$ denotes a normal probability density function), and Eq 1.10 describes the number of new recruits produced by plants as a function of size $z$.

```{r eval = FALSE}

library(ipmr)

# This section produces the result of Step 1 in Figure 1.1.

data_list <- list(
  s_i  = -0.65, # Intercept of the survival model (Logistic regression)
  s_z  = 0.75,  # Slope of the survival model
  G_i  = 0.96,  # Intercept of the growth model (Gaussian regression)
  G_z  = 0.66,  # Slope of the growth model
  sd_G = 0.67,  # Standard deviation of residuals of growth model
  mu_r = -0.08, # Mean of the recruit size distribution 
  sd_r = 0.76,  # Standard deviation of the recruit size distribution
  r_n_i = -1,   # Intercept of recruit production model (Poisson regression)
  r_n_z = 0.3   # Slope of recruit production model.
)

# Step 2 in Figure 1.1. This is how ipmr initializes a model object.
# All functions prefixed with define_* generate proto_ipm objects. These 
# are converted into IPMs using the make_ipm() function in step 5. 

example_proto_ipm <- init_ipm(sim_gen   = "simple", 
                              di_dd     = "di", 
                              det_stoch = "det") 

# Step 3 in Figure 1.1. Note the link between how the model was defined
# mathematically and how it is defined here. 

example_proto_ipm <- define_kernel(
  example_proto_ipm,
  name         = "P",
  formula      = surv * Grow,
  surv         = plogis(s_i + s_z * z_1),
  Grow         = dnorm(z_2, mu_G, sd_G),
  mu_G         = G_i + G_z * z_1,
  data_list    = data_list,
  states       = list(c("z"))
)

example_proto_ipm <- define_kernel(
  example_proto_ipm,
  name        = "F",
  formula     = recr_number * recr_size,
  recr_number = exp(r_n_i + r_n_z * z_1),
  recr_size   = dnorm(z_2, mu_r, sd_r),
  data_list   = data_list,
  states      = list(c("z"))
)

# Step 4 in Figure 1.1. These next 3 functions define:
# 1. The numerical integration rules and how to iterate the 
#    model (define_impl).
# 2. The range of values the the trait "z" can take on, and the number of
#    meshpoints to use when dividing the interval (define_domains).
# 3. The initial population state (define_pop_state).

example_proto_ipm <- define_impl(
  example_proto_ipm,
  list(
    P = list(int_rule = "midpoint", state_start = "z", state_end = "z"),
    F = list(int_rule = "midpoint", state_start = "z", state_end = "z")
  )
)

example_proto_ipm <- define_domains(
  example_proto_ipm,
  z = c(-2.65, 4.5, 250) # format: c(L, U, m), m is number of meshpoints
)

example_proto_ipm <- define_pop_state(
  example_proto_ipm,
  n_z = rep(1/250, 250)
) 

# Step 5 in Figure 1.1.

example_ipm <- make_ipm(example_proto_ipm)

# Step 6 in Figure 1.1. 

lambda(example_ipm)


```

*Box 1.1: Code to implement a simple IPM from parameter estimates in `ipmr`. Because `ipmr` does not include functions to assist with regression modeling, this example skips the step of working with actual data and instead uses hypothetical parameter values. We see that given this set of conditions, if nothing were to change, the population would increase by ~2% each year. The case studies provide details on further use cases and analyses that are possible with `ipmr`.*

The code in Box 1.1 substitutes the actual probability density function (`dnorm()`) for $f_G$ and $f_{r_d}$, and uses inverse link functions instead of link functions. Otherwise, the math and the code should look quite similar. 

## Case study 1 - A simple IPM

One use for IPMs is to evaluate potential performance and management of invasive species in their non-native range (_e.g._ Erickson et al., 2017). Calculating sensitivities  and elasticities of $\lambda$ to kernel perturbations can help identify conservation management strategies (de Kroon et al., 1986, Caswell, 2001, Baxter et al., 2006, Ellner et al., 2016). Bogdan et al. (2021) constructed a simple IPM for a *Carpobrotus* species growing north of Tel Aviv, Israel. The model includes four regressions, and an estimated recruit size distribution. Table 1.1 provides the mathematical formulae, the corresponding R model formulae, and the `ipmr` notation for each one. The case study materials also offer an alternative implementation that uses the generic `predict()` function to generate the same output. The final part of the case study provides examples of functions that compute kernel sensitivity and elasticity, the per-generation growth rate, and generation time for the model, as well as how to visualize these results. 

## Case study 2 - A general age $\times$ size IPM

We use an age- and size-structured IPM from Ellner et al. (2016) to illustrate how to create general IPMs with `ipmr`. This case study demonstrates the suffix syntax for vital rate and kernel expressions, which is a key feature of `ipmr` (highlighted in bold in the 'ipmr' column in Table 1.2). The suffixes appended to each variable name in the `ipmr` formulation correspond to the sub- and/or super-scripts used in the mathematical formulation. `ipmr` internally expands the model expressions and substitutes the range of ages and/or grouping variables in for the suffixes. This allows users to specify their model in a way that closely mirrors its mathematical notation, and saves users from the potentially error-prone process of re-typing model definitions many times or using `for` loops over the range of discrete states. The case study then demonstrates how to compute age-specific survival and fertility from the model outputs.

## Discussion of additional applications

We have shown above how `ipmr` handles a variety of model implementations that go beyond the capabilities of existing scripts and packages. The underlying implementation based on metaprogramming should be able to readily incorporate future developments in parameterization methods. Regression modeling is a field that is constantly introducing new methods. As long as these new methods have functional forms for their expected value (or a function to compute them, such as `predict()`), `ipmr` should be able to implement IPMs using them. 

Finally, one particularly useful aspect of the package is the `proto_ipm` data structure. The `proto_ipm` is the common data structure used to represent every model class in `ipmr` and provides a concise, standardized format for representing IPMs. Furthermore, the `proto_ipm` object is created without any raw data, only functional forms and parameters. The PADRINO IPM database uses `ipmr` and `proto_ipm`s as an "engine" to re-build published IPMs using only functional forms and parameter estimates. This database could act as an IPM equivalent of the popular COMPADRE and COMADRE matrix population model databases (Salguero-Gómez et al., 2015, Salguero-Gómez et al., 2016). Recent work has highlighted the power of syntheses that harness many structured population models (Adler et al., 2014, Salguero-Gómez et al., 2016, Compagnoni et al., 2021). Despite the wide variety of models that are currently published in the IPM literature, `ipmr`'s functional approach is able to reproduce nearly all of them without requiring any raw data at all. PADRINO and its usage are discussed in the next chapter of this dissertation.

\newpage
\pagenumbering{gobble}
\blandscape

```{r echo = FALSE}

tab_legend <- "Table 1.1: Translations between mathematical notation, R's formula notation, and ipmr's notation for the simplified version of Bogdan et al.'s Carpobrotus IPM. The ipmr column contains the expressions used in each kernel's definition. R expressions are not provided for sub-kernels and model iteration procedures because they typically require defining functions separately, and there are many ways to do this step (examples are in the R code for each case study in the appendix). The plogis() function computes the inverse logit transformation of an expression. $s$ corresponds to survival, $G$ corresponds to change in size conditional on survival, $r_p$ is the probability of reproducing, $r_n$ is the number of propagules produced by reproductive individuals, and $p_r$ is the probability that a propagule becomes a new recruit at $t+1$."

kable(
  data.frame(

    Math    = c("$\\mu_G = \\alpha_G + \\beta_G * z$",
                "$G(z',z) = f_G(z',\\mu_G, \\sigma_G)$",
                "$logit(s(z)) = \\alpha_s + \\beta_s * z$",
                "$log(r_n(z)) = \\alpha_{r_n} + \\beta_{r_n} * z$",
                "$logit(r_p(z)) = \\alpha_{r_p} + \\beta_{r_p} * z$",
                "$r_d(z') = f_{r_d}(z', \\mu_{r_d}, \\sigma_{r_d})$",
                "$p_r = \\frac{\\# Recruits (t+1)}{\\# flowers (t)}$",
                "$P = s(z) * G(z',z)$",
                "$F(z',z) = r_p(z) * r_n(z) * r_d(z') * p_r$",
                "$n(z', t+1) = \\int_L^U [P(z',z) + F(z',z)] n(z, t)dz$"),
    
    
    R = c("size\\_2 ~ size\\_1, family = gaussian()",
          "G = dnorm(z\\_2, mu\\_G, sd\\_G)",
          "surv ~ size\\_1, family = binomial()",
          "fec ~ size\\_1, family = poisson()",
          "repr ~ size\\_1, family = binomial()",
          "dnorm(z\\_2, mu\\_f\\_d, sigma\\_f\\_d)",
          "p\\_r = n\\_new\\_recruits / n\\_flowers",
          "",
          "",
          ""),
    
    
    ipmr = c("mu\\_G = G\\_int + G\\_slope * z",
             "G = dnorm(z\\_2, mu\\_G, sd\\_G)",
             "s = plogis(s\\_int + s\\_slope * z)",
             "r\\_n = exp(r\\_n\\_int + r\\_n\\_slope * z)",
             "r\\_p = plogis(r\\_p\\_int + r\\_p\\_slope * z)",
             "r\\_d = dnorm(z\\_2, f\\_d\\_mu, f\\_d\\_sigma)",
             "p\\_r = n\\_new / n\\_flowers",
             "P = s * G",
             "F = r\\_p * r\\_n * r\\_d * p\\_r",
             "")
  ),
  escape    = FALSE,
  col.names = c("Math Formula", "R Formula", "ipmr"),
  caption   = tab_legend
)

```

\elandscape

\newpage
\pagenumbering{gobble}
\blandscape

```{r echo = FALSE}

tab_legend <- "Table 1.2: Translations between mathematical notation, R's formula notation, and ipmr's notation for Ellner et al. (2016) Ovis aries IPM. The ipmr column contains the expressions used in each kernel's definition. R expressions are not provided for sub-kernels and model iteration procedures because they typically require defining functions separately, and there are many ways to do this step (examples are in the R code for each case study in the appendix). ipmr supports a suffix based syntax to avoid repetitively typing out the levels of discrete grouping variables. These are represented as 'a' in the Math column, 'age' in the R formula column, and are highlighted with '*'s in the ipmr column. $s$ corresponds to survival, $G$ corresponds to change in size conditional on survival, $m_p$ is the probability of mating, $r_p$  is the probability that a mating produces a new recruit at $t+1$, and $B$ is the size distribution of new recruits at $t+1$ whose mean depends on parent size at time $t$. $F_a$ is divided by 2 because this IPM only tracks females."

kable(
  data.frame(

    Math    = c(
      "$Logit(s(z,a)) = \\alpha_s + \\beta_{s,z} * z + \\beta_{s,a} * a$",
      "$G(z',z,a) = f_G(z', \\mu_{G}(z, a), \\sigma_{G})$",
      "$\\mu_G(z, a) = \\alpha_G + \\beta_{G,z} * z + \\beta_{G,a} * a$",
      "$Logit(m_p(z,a)) = \\alpha_{m_p} + \\beta_{m_p,z} * z + \\beta_{m_p,a} * a$",
      "$Logit(r_p(a)) = \\alpha_{r_p} + \\beta_{r_p,a} * a$",
      "$B(z',z) = f_B(z', \\mu_B(z), \\sigma_B)$",
      "$\\mu_B(z) = \\alpha_B + \\beta_{B, z} * z$",
      "$P_a(z',z) = s(z, a) * G(z',z, a)$",
      "$F_a(z',z) = s(z, a) * m_p(z, a) * r_p(a) * B(z', z) / 2$",
      "$n_0(z', t+1) = \\sum\\limits_{a=0}^{M+1}\\int_L^UF_a(z',z)n_a(z,t)dz$",
      "$n_a(z', t + 1) = \\int_L^U P_{a-1}(z',z) n_{a-1}(z,t) dz$",
      "$n_{M+1}(z', t + 1) = \\int_L^U[P_{M+1}(z',z) n_{M+1}(z,t) + P_{M}(z',z)n_{M}(z, t)]dz$"
    ),
    
      
    R = c(
      "surv ~ size\\_1 + age, family = binomial()",
      "G = dnorm(size\\_2, mu\\_G\\_age, sigma\\_G)",
      "size\\_2 ~ size\\_1 + age, family = gaussian()",
      "repr ~ size\\_1 + age, family = binomial()",
      "recr ~ age, family = binomial()",
      "b = dnorm(size\\_2, mu\\_rc\\_size, sigma\\_rc\\_size)",
      "rc\\_size\\_2 ~ size\\_1, family = gaussian()",
      "",
      "",
      "",
      "",
      ""
    ),
    
    ipmr = c(
      "s\\_*age* = plogis(s\\_int + s\\_z * z\\_1 + s\\_a * *age*)",
      "G\\_*age* = dnorm(z\\_2, mu\\_G\\_*age*, sigma\\_G)",
      "mu\\_G\\_*age* = G\\_int + G\\_z * z + G\\_a * *age*",
      "m\\_p\\_*age* = plogis(m\\_p\\_int + m\\_p\\_z * z + m\\_p\\_a * *age*)",
      "r\\_p\\_*age* = plogis(r\\_p\\_int + r\\_p\\_a * *age*)",
      "rc\\_size = dnorm(z\\_2, mu\\_rc\\_size, sigma\\_rc\\_size)",
      "mu\\_rc\\_size = rc\\_size\\_int + rc\\_size\\_z * z",
      "P\\_*age* = s\\_*age* * g\\_*age* * d\\_z",
      "F\\_*age* =   s\\_*age* * f\\_p\\_*age* * r\\_p\\_*age* * rc\\_size / 2",
      "",
      "",
      ""
    )
  ),
  escape    = FALSE,
  col.names = c("Math Formula", "R Formula", "ipmr"),
  caption   = tab_legend
) %>%
  kable_styling(latex_options = "scale_down")

```

\elandscape

\pagenumbering{arabic}
